---
phase: 07-broader-search-suggestions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/tools.ts
autonomous: true

must_haves:
  truths:
    - "Zero-result searches with restrictive operators return suggestions"
    - "Suggestions include broader query and human-readable reason"
    - "Simple queries (no operators) do not generate suggestions"
    - "Query parser handles quoted strings correctly"
    - "Query parser handles all 8 Gmail operators (from, to, subject, after, before, has, label, is)"
  artifacts:
    - path: "src/tools.ts"
      provides: "Gmail query parser and broader search suggestions"
      exports: ["parseGmailQuery", "generateBroaderSuggestions", "searchMessages"]
      contains: "interface ParsedQuery"
  key_links:
    - from: "searchMessages"
      to: "parseGmailQuery"
      via: "function call when messages.length === 0"
      pattern: "parseGmailQuery\\(params\\.query\\)"
    - from: "searchMessages"
      to: "generateBroaderSuggestions"
      via: "function call after parsing"
      pattern: "generateBroaderSuggestions\\(parsed\\)"
---

<objective>
Implement Gmail query parsing and broader search suggestions

Purpose: When searches return zero results with restrictive operators, help users find emails by suggesting broader queries (e.g., searching all fields instead of just sender)

Output: Modified `src/tools.ts` with query parser, suggestion generator, and enhanced `searchMessages()` function
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-broader-search-suggestions/07-RESEARCH.md
@.planning/features/BROADER_SEARCH_SUGGESTIONS.md
@src/tools.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TypeScript interfaces and parseGmailQuery function</name>
  <files>src/tools.ts</files>
  <action>
Add the following TypeScript interfaces near the top of the file (after the existing type declarations around line 4):

```typescript
/**
 * Parsed Gmail query components
 */
interface ParsedQuery {
  from?: string[];
  to?: string[];
  subject?: string[];
  body?: string[];
  after?: string;
  before?: string;
  hasAttachment?: boolean;
  label?: string[];
  isUnread?: boolean;
  raw: string;
}

/**
 * A single search suggestion
 */
interface SearchSuggestion {
  query: string;
  reason: string;
}

/**
 * Search suggestions for zero-result queries
 */
interface SearchSuggestions {
  noResults: boolean;
  broaderQueries: SearchSuggestion[];
  prompt: string;
}
```

Then add the `parseGmailQuery` function (can be placed before `searchMessages` around line 185):

```typescript
/**
 * Parses a Gmail search query into structured components
 * Handles operators: from:, to:, subject:, after:, before:, has:, label:, is:
 * Supports quoted values: from:"John Doe"
 */
function parseGmailQuery(query: string): ParsedQuery {
  const result: ParsedQuery = { raw: query };
  
  // Regex: captures operator name and either "quoted value" or unquoted-value
  const operatorRegex = /(\w+):(?:"([^"]+)"|(\S+))/gi;
  
  let match: RegExpExecArray | null;
  const matchedRanges: Array<[number, number]> = [];
  
  while ((match = operatorRegex.exec(query)) !== null) {
    const operator = match[1].toLowerCase();
    const value = match[2] || match[3]; // Quoted takes precedence
    
    if (!value) continue; // Skip empty values
    
    matchedRanges.push([match.index, match.index + match[0].length]);
    
    switch (operator) {
      case 'from':
        (result.from ??= []).push(value);
        break;
      case 'to':
        (result.to ??= []).push(value);
        break;
      case 'subject':
        (result.subject ??= []).push(value);
        break;
      case 'after':
        result.after = value;
        break;
      case 'before':
        result.before = value;
        break;
      case 'has':
        if (value.toLowerCase() === 'attachment') {
          result.hasAttachment = true;
        }
        break;
      case 'label':
        (result.label ??= []).push(value);
        break;
      case 'is':
        if (value.toLowerCase() === 'unread') {
          result.isUnread = true;
        }
        break;
    }
  }
  
  // Extract remaining text (body search terms)
  matchedRanges.sort((a, b) => b[0] - a[0]);
  let remaining = query;
  for (const [start, end] of matchedRanges) {
    remaining = remaining.slice(0, start) + remaining.slice(end);
  }
  remaining = remaining.trim();
  
  if (remaining) {
    const bodyTerms: string[] = [];
    const phraseRegex = /"([^"]+)"|(\S+)/g;
    let bodyMatch: RegExpExecArray | null;
    while ((bodyMatch = phraseRegex.exec(remaining)) !== null) {
      bodyTerms.push(bodyMatch[1] || bodyMatch[2]);
    }
    if (bodyTerms.length > 0) {
      result.body = bodyTerms;
    }
  }
  
  return result;
}
```

Key implementation notes:
- Regex is case-insensitive (`/gi` flag) to handle `FROM:`, `From:`, `from:`
- Quoted values handled via `(?:"([^"]+)"|(\S+))` pattern
- Empty operator values (e.g., `from:`) are skipped gracefully
- Remaining text after operators extracted becomes body search terms
  </action>
  <verify>
Run TypeScript compiler to verify no syntax errors:
```bash
npm run build
```
Should complete without errors. The new interfaces and function add no runtime behavior yet.
  </verify>
  <done>
- ParsedQuery, SearchSuggestion, SearchSuggestions interfaces defined
- parseGmailQuery function implemented
- TypeScript compiles successfully
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement generateBroaderSuggestions and integrate with searchMessages</name>
  <files>src/tools.ts</files>
  <action>
Add the `generateBroaderSuggestions` function after `parseGmailQuery`:

```typescript
/**
 * Generates broader search suggestions for a parsed query
 * Returns null if query has no operators (already broad) or no suggestions possible
 */
function generateBroaderSuggestions(parsed: ParsedQuery): SearchSuggestions | null {
  // BSS-04: Simple queries (no operators) do not generate suggestions
  const hasOperators = !!(
    parsed.from?.length ||
    parsed.to?.length ||
    parsed.subject?.length ||
    parsed.after ||
    parsed.before ||
    parsed.hasAttachment ||
    parsed.label?.length ||
    parsed.isUnread
  );
  
  if (!hasOperators) {
    return null;
  }
  
  const suggestions: SearchSuggestion[] = [];
  
  // Strategy 1: Extract words from field-specific operators and search all fields
  const fieldOperators: Array<{ field: string[]; name: string }> = [
    { field: parsed.from || [], name: 'sender' },
    { field: parsed.to || [], name: 'recipient' },
    { field: parsed.subject || [], name: 'subject' },
  ];
  
  for (const { field, name } of fieldOperators) {
    for (const value of field) {
      const words = value.split(/\s+/).filter(w => w.length > 2);
      for (const word of words) {
        suggestions.push({
          query: word,
          reason: `Search all fields for "${word}" instead of just the ${name}`
        });
      }
      // Multi-word values: also suggest full phrase
      if (words.length > 1) {
        suggestions.push({
          query: `"${value}"`,
          reason: `Search all fields for "${value}" as a phrase`
        });
      }
    }
  }
  
  // Strategy 2: Remove date restrictions
  if (parsed.after || parsed.before) {
    const parts: string[] = [];
    if (parsed.from) parts.push(...parsed.from.map(v => `from:${v.includes(' ') ? `"${v}"` : v}`));
    if (parsed.to) parts.push(...parsed.to.map(v => `to:${v.includes(' ') ? `"${v}"` : v}`));
    if (parsed.subject) parts.push(...parsed.subject.map(v => `subject:${v.includes(' ') ? `"${v}"` : v}`));
    if (parsed.body) parts.push(...parsed.body);
    if (parsed.label) parts.push(...parsed.label.map(v => `label:${v}`));
    
    if (parts.length > 0) {
      suggestions.push({
        query: parts.join(' '),
        reason: 'Remove date restrictions to search all time'
      });
    }
  }
  
  // Strategy 3: Remove label restrictions
  if (parsed.label?.length) {
    const parts: string[] = [];
    if (parsed.from) parts.push(...parsed.from.map(v => `from:${v.includes(' ') ? `"${v}"` : v}`));
    if (parsed.to) parts.push(...parsed.to.map(v => `to:${v.includes(' ') ? `"${v}"` : v}`));
    if (parsed.subject) parts.push(...parsed.subject.map(v => `subject:${v.includes(' ') ? `"${v}"` : v}`));
    if (parsed.body) parts.push(...parsed.body);
    if (parsed.after) parts.push(`after:${parsed.after}`);
    if (parsed.before) parts.push(`before:${parsed.before}`);
    
    if (parts.length > 0) {
      suggestions.push({
        query: parts.join(' '),
        reason: 'Search all labels instead of specific ones'
      });
    }
  }
  
  if (suggestions.length === 0) {
    return null;
  }
  
  // Deduplicate and limit to 5 suggestions
  const seen = new Set<string>();
  const uniqueSuggestions = suggestions.filter(s => {
    if (seen.has(s.query)) return false;
    seen.add(s.query);
    return true;
  }).slice(0, 5);
  
  return {
    noResults: true,
    broaderQueries: uniqueSuggestions,
    prompt: `No emails found matching "${parsed.raw}". Would you like me to try a broader search?`
  };
}
```

Now modify the `searchMessages` function (currently at lines 190-210). Update its return type and add suggestion logic:

Replace the existing `searchMessages` function with:

```typescript
/**
 * Search messages using Gmail query syntax
 * Returns suggestions for broader queries if search returns zero results
 */
export async function searchMessages(params: {
  query: string;
  maxResults?: number;
  pageToken?: string;
}): Promise<{
  messages: Array<{
    id: string;
    threadId: string;
    snippet: string;
    from: string;
    subject: string;
    date: string;
  }>;
  nextPageToken?: string;
  suggestions?: SearchSuggestions;
}> {
  const result = await listMessages({
    q: params.query,
    maxResults: params.maxResults,
    pageToken: params.pageToken,
  });

  // Only generate suggestions if no results
  if (result.messages.length === 0) {
    const parsed = parseGmailQuery(params.query);
    const suggestions = generateBroaderSuggestions(parsed);
    
    if (suggestions) {
      return {
        messages: result.messages.map(m => ({
          id: m.id,
          threadId: m.threadId,
          snippet: m.snippet,
          from: m.from,
          subject: m.subject,
          date: m.date,
        })),
        nextPageToken: result.nextPageToken,
        suggestions,
      };
    }
  }

  return {
    messages: result.messages.map(m => ({
      id: m.id,
      threadId: m.threadId,
      snippet: m.snippet,
      from: m.from,
      subject: m.subject,
      date: m.date,
    })),
    nextPageToken: result.nextPageToken,
  };
}
```

Key implementation notes:
- `suggestions` field is optional - only included when zero results AND operators present
- Return type updated to include `suggestions?: SearchSuggestions`
- Backward compatible: existing consumers see same shape when results found
- Message mapping explicit to strip `labelIds` from searchMessages output (different from listMessages)
  </action>
  <verify>
1. Build the project:
```bash
npm run build
```

2. Manually test the parser logic by examining the compiled output or adding temporary console.log statements. Key test cases from feature spec:
- `from:Don Stratton` should parse to `{ from: ["Don Stratton"], raw: "from:Don Stratton" }`
- `from:"John Doe"` should parse with quoted value preserved
- `meeting notes` (no operators) should return `{ body: ["meeting", "notes"], raw: "meeting notes" }`
  </verify>
  <done>
- generateBroaderSuggestions function implemented with 3 strategies
- searchMessages modified to return suggestions on zero results
- TypeScript compiles without errors
- Response shape backward compatible (suggestions optional)
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify all requirements with test scenarios</name>
  <files>src/tools.ts</files>
  <action>
Create a temporary test script to verify all requirements. Create file `test-suggestions.ts` in project root:

```typescript
// test-suggestions.ts - Temporary verification script
// Run with: npx tsx test-suggestions.ts

// Import the compiled functions (we'll test the logic inline since functions are not exported)

interface ParsedQuery {
  from?: string[];
  to?: string[];
  subject?: string[];
  body?: string[];
  after?: string;
  before?: string;
  hasAttachment?: boolean;
  label?: string[];
  isUnread?: boolean;
  raw: string;
}

interface SearchSuggestion {
  query: string;
  reason: string;
}

interface SearchSuggestions {
  noResults: boolean;
  broaderQueries: SearchSuggestion[];
  prompt: string;
}

// Copy parseGmailQuery implementation for testing
function parseGmailQuery(query: string): ParsedQuery {
  const result: ParsedQuery = { raw: query };
  const operatorRegex = /(\w+):(?:"([^"]+)"|(\S+))/gi;
  let match: RegExpExecArray | null;
  const matchedRanges: Array<[number, number]> = [];
  
  while ((match = operatorRegex.exec(query)) !== null) {
    const operator = match[1].toLowerCase();
    const value = match[2] || match[3];
    if (!value) continue;
    matchedRanges.push([match.index, match.index + match[0].length]);
    
    switch (operator) {
      case 'from': (result.from ??= []).push(value); break;
      case 'to': (result.to ??= []).push(value); break;
      case 'subject': (result.subject ??= []).push(value); break;
      case 'after': result.after = value; break;
      case 'before': result.before = value; break;
      case 'has': if (value.toLowerCase() === 'attachment') result.hasAttachment = true; break;
      case 'label': (result.label ??= []).push(value); break;
      case 'is': if (value.toLowerCase() === 'unread') result.isUnread = true; break;
    }
  }
  
  matchedRanges.sort((a, b) => b[0] - a[0]);
  let remaining = query;
  for (const [start, end] of matchedRanges) {
    remaining = remaining.slice(0, start) + remaining.slice(end);
  }
  remaining = remaining.trim();
  
  if (remaining) {
    const bodyTerms: string[] = [];
    const phraseRegex = /"([^"]+)"|(\S+)/g;
    let bodyMatch: RegExpExecArray | null;
    while ((bodyMatch = phraseRegex.exec(remaining)) !== null) {
      bodyTerms.push(bodyMatch[1] || bodyMatch[2]);
    }
    if (bodyTerms.length > 0) result.body = bodyTerms;
  }
  
  return result;
}

// Copy generateBroaderSuggestions for testing
function generateBroaderSuggestions(parsed: ParsedQuery): SearchSuggestions | null {
  const hasOperators = !!(
    parsed.from?.length || parsed.to?.length || parsed.subject?.length ||
    parsed.after || parsed.before || parsed.hasAttachment ||
    parsed.label?.length || parsed.isUnread
  );
  
  if (!hasOperators) return null;
  
  const suggestions: SearchSuggestion[] = [];
  const fieldOperators = [
    { field: parsed.from || [], name: 'sender' },
    { field: parsed.to || [], name: 'recipient' },
    { field: parsed.subject || [], name: 'subject' },
  ];
  
  for (const { field, name } of fieldOperators) {
    for (const value of field) {
      const words = value.split(/\s+/).filter(w => w.length > 2);
      for (const word of words) {
        suggestions.push({ query: word, reason: `Search all fields for "${word}" instead of just the ${name}` });
      }
      if (words.length > 1) {
        suggestions.push({ query: `"${value}"`, reason: `Search all fields for "${value}" as a phrase` });
      }
    }
  }
  
  if (parsed.after || parsed.before) {
    const parts: string[] = [];
    if (parsed.from) parts.push(...parsed.from.map(v => `from:${v.includes(' ') ? `"${v}"` : v}`));
    if (parsed.to) parts.push(...parsed.to.map(v => `to:${v.includes(' ') ? `"${v}"` : v}`));
    if (parsed.subject) parts.push(...parsed.subject.map(v => `subject:${v.includes(' ') ? `"${v}"` : v}`));
    if (parsed.body) parts.push(...parsed.body);
    if (parsed.label) parts.push(...parsed.label.map(v => `label:${v}`));
    if (parts.length > 0) {
      suggestions.push({ query: parts.join(' '), reason: 'Remove date restrictions to search all time' });
    }
  }
  
  if (parsed.label?.length) {
    const parts: string[] = [];
    if (parsed.from) parts.push(...parsed.from.map(v => `from:${v.includes(' ') ? `"${v}"` : v}`));
    if (parsed.to) parts.push(...parsed.to.map(v => `to:${v.includes(' ') ? `"${v}"` : v}`));
    if (parsed.subject) parts.push(...parsed.subject.map(v => `subject:${v.includes(' ') ? `"${v}"` : v}`));
    if (parsed.body) parts.push(...parsed.body);
    if (parsed.after) parts.push(`after:${parsed.after}`);
    if (parsed.before) parts.push(`before:${parsed.before}`);
    if (parts.length > 0) {
      suggestions.push({ query: parts.join(' '), reason: 'Search all labels instead of specific ones' });
    }
  }
  
  if (suggestions.length === 0) return null;
  
  const seen = new Set<string>();
  const uniqueSuggestions = suggestions.filter(s => {
    if (seen.has(s.query)) return false;
    seen.add(s.query);
    return true;
  }).slice(0, 5);
  
  return {
    noResults: true,
    broaderQueries: uniqueSuggestions,
    prompt: `No emails found matching "${parsed.raw}". Would you like me to try a broader search?`
  };
}

// Test cases
console.log("=== BSS-01: Query parser handles Gmail operators ===");
const test1 = parseGmailQuery("from:john@example.com");
console.log("from:john@example.com ->", JSON.stringify(test1));
console.assert(test1.from?.[0] === "john@example.com", "FAIL: from operator");

const test2 = parseGmailQuery("to:jane subject:meeting after:2025/01/01 before:2025/02/01");
console.log("Complex query ->", JSON.stringify(test2));
console.assert(test2.to?.[0] === "jane", "FAIL: to operator");
console.assert(test2.subject?.[0] === "meeting", "FAIL: subject operator");
console.assert(test2.after === "2025/01/01", "FAIL: after operator");
console.assert(test2.before === "2025/02/01", "FAIL: before operator");

const test3 = parseGmailQuery("has:attachment label:work is:unread");
console.log("Boolean operators ->", JSON.stringify(test3));
console.assert(test3.hasAttachment === true, "FAIL: has:attachment");
console.assert(test3.label?.[0] === "work", "FAIL: label operator");
console.assert(test3.isUnread === true, "FAIL: is:unread");

console.log("\n=== BSS-02: Quoted strings handled ===");
const test4 = parseGmailQuery('from:"Don Stratton"');
console.log('from:"Don Stratton" ->', JSON.stringify(test4));
console.assert(test4.from?.[0] === "Don Stratton", "FAIL: quoted value not preserved");

const test5 = parseGmailQuery('subject:"Weekly Report" from:boss');
console.log('Mixed quoted/unquoted ->', JSON.stringify(test5));
console.assert(test5.subject?.[0] === "Weekly Report", "FAIL: quoted subject");
console.assert(test5.from?.[0] === "boss", "FAIL: unquoted from");

console.log("\n=== BSS-03: Suggestions for restrictive operators ===");
const parsed1 = parseGmailQuery("from:Don Stratton");
const suggestions1 = generateBroaderSuggestions(parsed1);
console.log("from:Don Stratton suggestions:", JSON.stringify(suggestions1, null, 2));
console.assert(suggestions1 !== null, "FAIL: should generate suggestions");
console.assert(suggestions1!.broaderQueries.some(s => s.query === "Stratton"), "FAIL: should suggest Stratton");

const parsed2 = parseGmailQuery("subject:invoice after:2025/01/01");
const suggestions2 = generateBroaderSuggestions(parsed2);
console.log("subject:invoice after:... suggestions:", JSON.stringify(suggestions2, null, 2));
console.assert(suggestions2!.broaderQueries.some(s => s.reason.includes("date")), "FAIL: should suggest removing date");

console.log("\n=== BSS-04: Simple queries do NOT generate suggestions ===");
const parsed3 = parseGmailQuery("meeting notes");
const suggestions3 = generateBroaderSuggestions(parsed3);
console.log("meeting notes suggestions:", suggestions3);
console.assert(suggestions3 === null, "FAIL: simple query should return null");

const parsed4 = parseGmailQuery("Stratton");
const suggestions4 = generateBroaderSuggestions(parsed4);
console.log("Stratton suggestions:", suggestions4);
console.assert(suggestions4 === null, "FAIL: single word should return null");

console.log("\n=== All tests passed! ===");
```

Run the test:
```bash
npx tsx test-suggestions.ts
```

After verification passes, delete the test file:
```bash
rm test-suggestions.ts
```
  </action>
  <verify>
All console.assert statements pass without throwing errors. Expected output ends with "=== All tests passed! ===".

Final build verification:
```bash
npm run build
```
  </verify>
  <done>
- BSS-01: All 8 Gmail operators parsed correctly (from, to, subject, after, before, has, label, is)
- BSS-02: Quoted strings like `from:"Don Stratton"` preserve the full value
- BSS-03: Restrictive operators generate meaningful suggestions
- BSS-04: Simple queries (no operators) return null suggestions
- Test file cleaned up
- Build succeeds
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Build passes:** `npm run build` completes without errors
2. **Parser handles all operators:** Test each of the 8 operators works
3. **Quoted strings work:** `from:"John Doe"` parses correctly
4. **Suggestions generated:** Zero-result searches with operators return suggestions
5. **No false suggestions:** Plain text queries don't get suggestions
6. **Backward compatible:** Response shape unchanged when results exist
</verification>

<success_criteria>
- [ ] TypeScript compiles without errors
- [ ] parseGmailQuery correctly parses all 8 Gmail operators
- [ ] parseGmailQuery handles quoted strings (BSS-02)
- [ ] generateBroaderSuggestions returns suggestions for restrictive queries (BSS-03)
- [ ] generateBroaderSuggestions returns null for simple queries (BSS-04)
- [ ] searchMessages includes suggestions field only when appropriate
- [ ] All test assertions pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-broader-search-suggestions/07-01-SUMMARY.md`
</output>
